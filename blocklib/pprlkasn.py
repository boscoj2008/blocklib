import bisect
from blocklib.configuration import get_config
from blocklib.pprlindex import PPRLIndex
from blocklib import simmeasure


class PPRLIndexKAnonymousSortedNeighbour(PPRLIndex):
    """Class that implements a sorted neighbourhood based PPRL indexing
     technique.

     Blocks are generated by sorting reference values, and inserting the
     values from the databases into an inverted index where reference values
     are the keys. Blocks are then formed that each contain at least k
     records.
    """

    def __init__(self, config):
        """Initialise the class and set the required parameters.

           Arguments:
            - config: dict
                Configuration for KASN reverted index, including:
               - k                  The minimum block size (in number of records that
                                    need to be in a block).
               - sim_measure        A string which specifies which similarity
                                    function to use
               - min_sim_threshold  A similarity threshold between 0 and 1 which is
                                    used to decide if a value is to be added to an
                                    existing cluster (if a similarity value is equal
                                    to or larger than this minimum threshold, or if a
                                    new cluster is to be generated (if the similarity
                                    is below this threshold).
               - overlap            An integer value that is used to generate
                                    overlapping blocks when generating candidate
                                    record pairs.
               - sim_or_size        The merging of blocks is either determined by the
                                    minimum similarity between adjacent reference
                                    values, or by merging blocks until they each
                                    contain k record identifiers.
        """
        super().__init__()
        self.k = get_config(config, 'k')
        self.ref_data_config = get_config(config, 'ref_data_config')
        self.min_sim_threshold = get_config(config, 'min_sim_threshold')
        self.overlap = get_config(config, 'overlap')
        self.default_features = get_config(config, 'default_features')
        self.sim_or_size = get_config(config, 'sim_or_size')
        self.sorted_first_val = get_config(config, 'sorted_first_val')
        if self.sim_or_size not in ['SIM', 'SIZE']:
            raise ValueError('KASN: Please only pass "SIM" or "SIZE" for config "sim_or_size"')

        # initialize sim measure instance
        sim_config = get_config(config, 'sim_measure')
        sim_algorithm = get_config(sim_config, 'algorithm')
        if sim_algorithm == 'Dice':
            self.sim = simmeasure.DiceSim(sim_config)
        elif sim_algorithm == 'Edit' or sim_algorithm == 'Levenshtein':
            self.sim = simmeasure.EditSim(sim_config)
        else:
            raise NotImplementedError('Similarity algorithm "{}" is not implemented yet!'.format(sim_algorithm))

    def generate_sorted_index(self, config):
        """Generate the blocks for the given record dictionary.
        """
        # initialize reference data list
        ref_val_list = self.load_reference_data(self.ref_data_config)

        # generate sorted reference value and assign integer value
        sort_ref_val_list = sorted(ref_val_list)
        ref_ind_dict = {}
        ref_ind_dict[0] = self.sorted_first_val
        for ind, ref_val in enumerate(sort_ref_val_list):
            ref_ind_dict[ind + 1] = ref_val

        self.ref_ind_dict = ref_ind_dict
        self.ref_val_list = ref_val_list
        self.sort_ref_val_list = sort_ref_val_list


    def build_inverted_index(self, data, rec_id_col=None):
        """Build inverted index for KASN method.

        Each record (its record identifier) is inserted into one block according
        to the sorting key values.
        """
        self.generate_sorted_index(self.ref_data_config)
        ## Two different max block size criteria:
        # a) min similarity between reference values
        # b) max number of records in a block to be merged

        m = 5
        ref_ind_dict = self.ref_ind_dict
        ref_val_list = self.ref_val_list
        sort_ref_val_list = self.sort_ref_val_list

        min_sim_threshold = self.min_sim_threshold

        # create reference value dict
        ref_val_dict = {}
        ref_val_dict[self.sorted_first_val] = []  # empty list of attribute for this block
        for ref_val in sort_ref_val_list:
            ref_val_dict[ref_val] = []

        point = int(len(data) / 5)
        for num_rec_done, rec_list in enumerate(data):
            if num_rec_done % point == 0:
                print('KASN: Processed {} records'.format(num_rec_done))

            # generate SKV for this record
            sk_val = ''.join([rec_list[x] for x in self.default_features])

            # Find the position of this SKV in the sorted list of ref vals and
            # insert it into the corresponding list of record identifiers in the
            # reference dictionary

            pos = bisect.bisect(sort_ref_val_list, sk_val)
            ref_val = ref_ind_dict[pos]
            skvs_list = ref_val_dict[ref_val]
            skvs_list.append(num_rec_done)
            ref_val_dict[ref_val] = skvs_list

        if self.sim_or_size == 'SIM':
            block_dict = self.build_by_sim(ref_ind_dict, ref_val_dict)
        else:
            block_dict = self.build_by_size(ref_ind_dict, ref_val_dict)
        return block_dict

    def build_by_sim(self, ref_ind_dict, ref_val_dict):
        """Build inverted index by min similarity between ref values.

        Merge blocks if they contain less than k elements.
        """
        k = self.k
        min_sim_threshold = self.min_sim_threshold
        # declare block dict
        block_dict = {}
        blk_keys = []

        sort_ref_val_list = self.sort_ref_val_list
        len_sort_ref_list = len(sort_ref_val_list)
        i = 0
        while i < len_sort_ref_list:
            j = 0
            num_elements = 0
            this_blk_elements_list = []

            sim_val = 0.0

            # The minimum number of elements in a block must be k, while the maximum
            # num of elements depends on the similarity between the ref values
            #
            # while ((num_elements <= k) and (i + j < len_sort_ref_list)) or \
            #       ((sim_val >= min_sim_threshold) and (i + j < len_sort_ref_list)):
            while (((num_elements <= k) and (i+j < len_sort_ref_list)) or ((sim_val >= min_sim_threshold) and (i+j < len_sort_ref_list))):
                this_ref_val = ref_ind_dict[i + 1]
                this_element_list = ref_val_dict[this_ref_val]
                num_elements += len(this_element_list)
                this_blk_elements_list += this_element_list

                # Similarity of the next (if not the last) ref value with this ref value
                if (i + j + 1) != len_sort_ref_list:
                    next_ref_val = ref_ind_dict[i + j + 1]
                    min_len = int(3 * min(len(this_ref_val), len(next_ref_val)) / 4)
                    sim_val = self.sim.sim(this_ref_val[:min_len], next_ref_val[:min_len])
                j += 1
            # If a block contains less than k elements (probably the last block)
            # merge it with the previous block
            #
            if len(this_blk_elements_list) < k:
                prev_blk_str = '_' + str(i - 1) + '_'
                prev_blk_id = next(k for (k,v) in block_dict.items() if \
                              prev_blk_str in k)
                this_blk_elements_list += block_dict[prev_blk_id]
                block_id = prev_blk_id
                del block_dict[prev_blk_id]
                blk_keys.remove(prev_blk_id)
            else:
                block_id = 'b_'

            # Generate the block identifier of this block consisting of the indices
            # of all the reference values in the block
            #
            for b in range(j):
                block_id += str(i+b)+'_'

            # Insert the list of record identifiers for this block into final dict
            #
            block_dict[block_id] = this_blk_elements_list
            blk_keys.append(block_id)
            i += j

        return block_dict

    def build_by_size(self, ref_ind_dict, ref_val_dict):
        """Build inverted index by max number of records in a block to be merged

        """
        k = self.k
        block_dict = {}
        blk_size = {}
        blk_keys = []

        for ref_ind in ref_ind_dict:
            ref_val = ref_ind_dict[ref_ind]
            attr_vals = ref_val_dict[ref_val]
            blk_id = 'b_'+str(ref_ind)+'_'
            block_dict[blk_id]=attr_vals
            blk_keys.append(blk_id)
            blk_size[blk_id] = len(attr_vals)

        merge_block = ''
        min_size_blk = min(blk_size, key=blk_size.get)
        min_size = blk_size[min_size_blk]
        while (min_size < k and len(blk_keys)>1):
            bid = min_size_blk
            s = blk_keys.index(bid)
            blk_vals = block_dict[min_size_blk]
            if s!=0 and s!= len(blk_keys)-1:     ## middle blocks
                prev_blk_id = blk_keys[s-1]
                prev_blk_vals = block_dict[prev_blk_id]
                num_prev_blk_vals = len(prev_blk_vals)
                next_blk_id = blk_keys[s+1]
                next_blk_vals = block_dict[next_blk_id]
                num_next_blk_vals = len(next_blk_vals)
                merge_block = 'prev' if num_prev_blk_vals < num_next_blk_vals else 'next'
            elif s == 0:                         ## first block
                next_blk_id = blk_keys[s+1]
                next_blk_vals = block_dict[next_blk_id]
                merge_block = 'next'
            elif s == len(blk_keys)-1:           ## last block
                prev_blk_id = blk_keys[s-1]
                prev_blk_vals = block_dict[prev_blk_id]
                merge_block = 'prev'

            if merge_block == 'prev':     #merge with next block
                prev_blk_vals += blk_vals
                new_blk_id = prev_blk_id + bid[2:]
                block_dict[new_blk_id] = prev_blk_vals #new block
                del block_dict[prev_blk_id] #del prev block
                blk_keys[s-1] = new_blk_id
                del blk_keys[s]
                blk_size[new_blk_id] = len(prev_blk_vals)
                del blk_size[prev_blk_id]
                del block_dict[bid] #del this block
                del blk_size[bid]
            elif merge_block == 'next':    #merge with previous block
                next_blk_vals += blk_vals
                new_blk_id = bid + next_blk_id[2:]
                block_dict[new_blk_id] = next_blk_vals #new block
                del block_dict[next_blk_id] #del next block
                blk_keys[s+1] = new_blk_id
                del blk_keys[s]
                blk_size[new_blk_id] = len(next_blk_vals)
                del blk_size[next_blk_id]
                del block_dict[bid]  #del this block
                del blk_size[bid]

            min_size_blk = min(blk_size, key=blk_size.get)
            min_size = blk_size[min_size_blk]

        return block_dict
